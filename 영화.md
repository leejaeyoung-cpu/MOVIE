# ğŸ¬ ìƒì—…ì  ì˜í™” ë¦¬ë·° ë° ì¶”ì²œ ì‹œìŠ¤í…œ ë¶„ì„ ë³´ê³ ì„œ

## ğŸ“‹ ëª©ì°¨
1. [ì£¼ìš” í”Œë«í¼ ë¶„ì„](#ì£¼ìš”-í”Œë«í¼-ë¶„ì„)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [í•µì‹¬ ê¸°ìˆ  ë° ì•Œê³ ë¦¬ì¦˜](#í•µì‹¬-ê¸°ìˆ -ë°-ì•Œê³ ë¦¬ì¦˜)
4. [í‰ì  ì‹œìŠ¤í…œ ë¹„êµ](#í‰ì -ì‹œìŠ¤í…œ-ë¹„êµ)
5. [ì¶”ì²œ ì‹œìŠ¤í…œ ì‹¬í™”](#ì¶”ì²œ-ì‹œìŠ¤í…œ-ì‹¬í™”)
6. [í”„ë¡œë•ì…˜ ë ˆë²¨ êµ¬í˜„](#í”„ë¡œë•ì…˜-ë ˆë²¨-êµ¬í˜„)
7. [ìš°ë¦¬ í”„ë¡œì íŠ¸ì™€ì˜ ë¹„êµ](#ìš°ë¦¬-í”„ë¡œì íŠ¸ì™€ì˜-ë¹„êµ)

---

## 1. ì£¼ìš” í”Œë«í¼ ë¶„ì„

### 1.1 IMDb (Internet Movie Database)

**ê°œìš”**
- ì„¤ë¦½: 1990ë…„
- ê°€ì¥ ì˜¤ë˜ëœ ì˜í™” ë°ì´í„°ë² ì´ìŠ¤
- Amazon ì†Œìœ  (1998ë…„ ì¸ìˆ˜)

**í•µì‹¬ ê¸°ëŠ¥**
- ì‚¬ìš©ì í‰ì  ê¸°ë°˜ ì ìˆ˜ (1-10ì )
- ì˜í™”, TV, ê²Œì„ ì •ë³´ í†µí•©
- ë°°ìš°/ê°ë… êµì°¨ ì°¸ì¡°
- ë¦¬ë·° ë° í‰ë¡  ê²Œì‹œ

**í‰ì  ì‹œìŠ¤í…œ**
- **ì ìˆ˜ ë²”ìœ„**: 0-10 (ì†Œìˆ˜ì  1ìë¦¬)
- **ê³„ì‚° ë°©ì‹**: ê°€ì¤‘ í‰ê·  (Weighted Average)
- **íŠ¹ì§•**: 
  - ëª¨ë“  ë“±ë¡ ì‚¬ìš©ì ì°¸ì—¬ ê°€ëŠ¥
  - íˆ¬í‘œ ì¡°ì‘ ë°©ì§€ ì•Œê³ ë¦¬ì¦˜ ì ìš©
  - íŒ¬ë“¤ì˜ 10ì  í­ê²©ìœ¼ë¡œ ì¸í”Œë ˆì´ì…˜ ê°€ëŠ¥

**ê¸°ìˆ  ìŠ¤íƒ (ì¶”ì •)**
```
Frontend: React, JavaScript
Backend: Java, Python
Database: PostgreSQL, DynamoDB
Cache: Redis, Memcached
CDN: Amazon CloudFront
Infrastructure: AWS
```

---

### 1.2 Rotten Tomatoes

**ê°œìš”**
- ì„¤ë¦½: 1998ë…„
- Fandango ì†Œìœ  (2016ë…„ ì¸ìˆ˜)
- ë¹„í‰ê°€ ì¤‘ì‹¬ í‰ê°€ ì‹œìŠ¤í…œ

**í•µì‹¬ ê¸°ëŠ¥**
- Tomatometer (ë¹„í‰ê°€ ì ìˆ˜)
- Audience Score (ê´€ê° ì ìˆ˜)
- Fresh/Rotten ì´ë¶„ë²•

**í‰ì  ì‹œìŠ¤í…œ**
- **Tomatometer**: ê¸ì • ë¦¬ë·° ë¹„ìœ¨ (0-100%)
  - Fresh (ê¸ì •): 60% ì´ìƒ
  - Rotten (ë¶€ì •): 60% ë¯¸ë§Œ
  - Certified Fresh: 75% ì´ìƒ + ë¦¬ë·° 40ê°œ ì´ìƒ
- **ê³„ì‚° ë°©ì‹**: 
  ```python
  tomatometer = (ê¸ì • ë¦¬ë·° ìˆ˜ / ì „ì²´ ë¦¬ë·° ìˆ˜) * 100
  ```
- **ë¬¸ì œì **: ëª¨ë“  ë¦¬ë·°ë¥¼ 100 ë˜ëŠ” 0ìœ¼ë¡œ ë‹¨ìˆœí™”
  - 3.5/5ì  ë¦¬ë·° â†’ Fresh (100)
  - 2.5/5ì  ë¦¬ë·° â†’ Rotten (0)

**ìŠ¹ì¸ëœ ë¹„í‰ê°€ ê¸°ì¤€**
- ì£¼ìš” ì–¸ë¡ ì‚¬ ì†Œì†
- ì •ê¸°ì  ë¦¬ë·° ë°œí–‰
- ìµœì†Œ 300ë‹¨ì–´ ì´ìƒ
- ì €ë„ë¦¬ì¦˜ ìê²©ì¦ ìš°ëŒ€

**ê¸°ìˆ  ìŠ¤íƒ**
```
Frontend: React, TypeScript
Backend: Node.js, Python
Database: MySQL, MongoDB
API: RESTful API
Analytics: Google Analytics
```

---

### 1.3 Metacritic

**ê°œìš”**
- ì„¤ë¦½: 2001ë…„
- CBS Interactive ì†Œìœ 
- ì˜í™”, ê²Œì„, ìŒì•…, TV í†µí•©

**í•µì‹¬ ê¸°ëŠ¥**
- Metascore (ë¹„í‰ê°€ ê°€ì¤‘ í‰ê· )
- User Score (ì‚¬ìš©ì ì ìˆ˜)
- ì»¬ëŸ¬ ì½”ë”© ì‹œìŠ¤í…œ

**í‰ì  ì‹œìŠ¤í…œ**
- **Metascore**: 0-100 ì 
  - Green (ì¢‹ìŒ): 61-100
  - Yellow (ë³´í†µ): 40-60
  - Red (ë‚˜ì¨): 0-39
- **ê³„ì‚° ë°©ì‹**: ê°€ì¤‘ í‰ê·  (Weighted Average)
  ```python
  metascore = Î£(review_score_i Ã— weight_i) / Î£(weight_i)
  ```
- **ê°€ì¤‘ì¹˜**: ë¹„ê³µê°œ (ì¶œì²˜ í‰íŒ ê¸°ë°˜)
  - Roger Ebert â†’ ë†’ì€ ê°€ì¤‘ì¹˜
  - ì†Œê·œëª¨ ë¸”ë¡œê·¸ â†’ ë‚®ì€ ê°€ì¤‘ì¹˜

**ì ìˆ˜ ë³€í™˜ ê·œì¹™**
| ì›ë˜ ì ìˆ˜ | Metascore |
|----------|-----------|
| A        | 100       |
| A-       | 92        |
| B+       | 83        |
| B        | 75        |
| B-       | 67        |
| C+       | 58        |
| F        | 0         |

**ê¸°ìˆ  ìŠ¤íƒ**
```
Frontend: JavaScript, HTML5
Backend: PHP, Python
Database: MySQL
Cache: Varnish
CDN: Akamai
```

---

### 1.4 Netflix (ì¶”ì²œ ì‹œìŠ¤í…œ)

**ê°œìš”**
- ì„¤ë¦½: 1997ë…„ (DVD), 2007ë…„ (ìŠ¤íŠ¸ë¦¬ë°)
- ì„¸ê³„ ìµœê³  ìˆ˜ì¤€ ì¶”ì²œ ì‹œìŠ¤í…œ
- 80% ì½˜í…ì¸ ê°€ ì¶”ì²œìœ¼ë¡œ ë°œê²¬ë¨

**í•µì‹¬ ê¸°ëŠ¥**
- ê°œì¸í™”ëœ í™ˆí˜ì´ì§€
- ë™ì  ì¸ë„¤ì¼ ì„ íƒ
- ì‹¤ì‹œê°„ ì¶”ì²œ ì—…ë°ì´íŠ¸
- ë‹¤ì¤‘ ëª©í‘œ ìµœì í™”

**ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER INTERFACE                       â”‚
â”‚  - Homepage Personalization                             â”‚
â”‚  - Thumbnail Selection (Contextual Bandits)             â”‚
â”‚  - Row Generation & Ranking                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RECOMMENDATION LAYER                       â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Collaborative   â”‚  â”‚ Content-Basedâ”‚  â”‚ Deep      â”‚ â”‚
â”‚  â”‚ Filtering       â”‚  â”‚ Filtering    â”‚  â”‚ Learning  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Hybrid Ensemble (Multi-Task Learning)           â”‚   â”‚
â”‚  â”‚ - PVR (Personalized Video Ranking)              â”‚   â”‚
â”‚  â”‚ - Top-N Ranker                                   â”‚   â”‚
â”‚  â”‚ - Because You Watched (BYW)                      â”‚   â”‚
â”‚  â”‚ - Trending Now                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MACHINE LEARNING PLATFORM                  â”‚
â”‚                                                         â”‚
â”‚  Data Ingestion â†’ Feature Engineering â†’ Model Training â”‚
â”‚  â†“                â†“                      â†“              â”‚
â”‚  Kafka            Spark/Flink           TensorFlow     â”‚
â”‚  Kinesis          Python                PyTorch        â”‚
â”‚                   Scala                 Horovod        â”‚
â”‚                                                         â”‚
â”‚  Model Deployment â†’ A/B Testing â†’ Continuous Learning  â”‚
â”‚  â†“                  â†“              â†“                    â”‚
â”‚  Docker             Experimentation Real-time         â”‚
â”‚  Kubernetes         Platform        Feedback          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DATA LAYER                            â”‚
â”‚                                                         â”‚
â”‚  Storage: Cassandra, S3, HDFS                          â”‚
â”‚  Processing: Apache Spark, Presto                       â”‚
â”‚  Streaming: Kafka, Flink                                â”‚
â”‚  Cache: EVCache, Redis                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜

ëŒ€ë¶€ë¶„ì˜ ìƒì—…ì  ì‹œìŠ¤í…œì€ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ êµ¬ì¡° ì‚¬ìš©:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   API GATEWAY                          â”‚
â”‚            (Kong, AWS API Gateway)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        â”‚        â”‚            â”‚          â”‚
    â–¼        â–¼        â–¼            â–¼          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚User    â”‚â”‚Movie â”‚â”‚Review   â”‚â”‚Rating    â”‚â”‚Search  â”‚
â”‚Service â”‚â”‚      â”‚â”‚Service  â”‚â”‚Service   â”‚â”‚Service â”‚
â”‚        â”‚â”‚Data  â”‚â”‚         â”‚â”‚          â”‚â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚        â”‚        â”‚            â”‚          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Message Queue â”‚
              â”‚  (Kafka/RabbitMQ)â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Event Processing      â”‚
          â”‚  (Recommendation, ML)  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                 â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                 â”‚  Cache   â”‚
                 â”‚  (Redis) â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ë°ì´í„° íŒŒì´í”„ë¼ì¸

```
ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘
â†“
[Kafka] â†’ [Spark Streaming] â†’ [Feature Store]
                                      â†“
ë°°ì¹˜ ì²˜ë¦¬                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â†“                                  â”‚ ML Models  â”‚
[S3/HDFS] â†’ [Spark Batch] â†’      â”‚ Training   â”‚
                            â†˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ Model Servingâ”‚
                              â”‚ (TensorFlow) â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. í•µì‹¬ ê¸°ìˆ  ë° ì•Œê³ ë¦¬ì¦˜

### 3.1 ê°ì„± ë¶„ì„ (Sentiment Analysis)

#### A. ì „í†µì  ë°©ë²•

**1. Naive Bayes**
```python
from sklearn.naive_bayes import MultinomialNB

# íŠ¹ì§•: ë¹ ë¥´ê³  íš¨ìœ¨ì 
# ì •í™•ë„: 76-80%
# ì‚¬ìš©ì²˜: ì´ˆê¸° Rotten Tomatoes, IMDb
```

**2. Support Vector Machine (SVM)**
```python
from sklearn.svm import SVC

# íŠ¹ì§•: ë†’ì€ ì •í™•ë„
# ì •í™•ë„: 85-90%
# ì‚¬ìš©ì²˜: Metacritic ì´ˆê¸° ë²„ì „
```

#### B. ë”¥ëŸ¬ë‹ ë°©ë²•

**1. LSTM (Long Short-Term Memory)**
```python
from tensorflow.keras.layers import LSTM, Embedding, Dense
from tensorflow.keras.models import Sequential

model = Sequential([
    Embedding(vocab_size, 128),
    LSTM(64, return_sequences=True),
    LSTM(32),
    Dense(3, activation='softmax')  # positive/negative/neutral
])

# íŠ¹ì§•: ë¬¸ë§¥ ì´í•´ ìš°ìˆ˜
# ì •í™•ë„: 88-92%
# ì‚¬ìš©ì²˜: IMDb ìµœì‹  ì‹œìŠ¤í…œ
```

**2. CNN (Convolutional Neural Network)**
```python
from tensorflow.keras.layers import Conv1D, GlobalMaxPooling1D

model = Sequential([
    Embedding(vocab_size, 128),
    Conv1D(128, 5, activation='relu'),
    GlobalMaxPooling1D(),
    Dense(64, activation='relu'),
    Dense(3, activation='softmax')
])

# íŠ¹ì§•: ë¹ ë¥¸ í•™ìŠµ, ì§€ì—­ì  íŒ¨í„´ ê°ì§€
# ì •í™•ë„: 85-90%
# í•™ìŠµ ì‹œê°„: LSTMì˜ 1/3
```

**3. Transformer ê¸°ë°˜ (BERT, RoBERTa)**
```python
from transformers import BertForSequenceClassification, BertTokenizer

model = BertForSequenceClassification.from_pretrained(
    'bert-base-uncased',
    num_labels=3
)

# íŠ¹ì§•: ìµœê³  ìˆ˜ì¤€ ì •í™•ë„
# ì •í™•ë„: 93-96%
# ì‚¬ìš©ì²˜: Netflix, Rotten Tomatoes (ìµœì‹ )
```

**í•œêµ­ì–´ íŠ¹í™”: KoBERT**
```python
from transformers import AutoModel, AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("monologg/kobert")
model = AutoModel.from_pretrained("monologg/kobert")

# ì •í™•ë„: 91-94% (í•œêµ­ì–´ ë¦¬ë·°)
# íŒŒë¼ë¯¸í„°: ~110M
```

#### C. ìµœì‹  ê¸°ë²•: Aspect-Based Sentiment Analysis

```python
# ì˜í™”ì˜ ì—¬ëŸ¬ ì¸¡ë©´ì— ëŒ€í•œ ê°ì„± ë¶„ì„
aspects = {
    'acting': 'positive',     # ì—°ê¸°: ê¸ì •
    'plot': 'negative',       # ì¤„ê±°ë¦¬: ë¶€ì •
    'cinematography': 'positive',  # ì´¬ì˜: ê¸ì •
    'soundtrack': 'neutral'   # ìŒì•…: ì¤‘ë¦½
}

# ì˜ˆ: "ì—°ê¸°ëŠ” í›Œë¥­í–ˆì§€ë§Œ ìŠ¤í† ë¦¬ê°€ ì§€ë£¨í–ˆë‹¤"
# â†’ ì—°ê¸°(+0.9), ìŠ¤í† ë¦¬(-0.7)
```

**ì‚¬ìš© í”Œë«í¼**: Metacritic, Rotten Tomatoes (í”„ë¦¬ë¯¸ì—„ ê¸°ëŠ¥)

---

### 3.2 ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜

#### A. Collaborative Filtering (í˜‘ì—… í•„í„°ë§)

**1. User-Based Collaborative Filtering**
```python
from sklearn.metrics.pairwise import cosine_similarity

# ìœ ì‚¬í•œ ì‚¬ìš©ì ì°¾ê¸°
user_similarity = cosine_similarity(user_rating_matrix)

# ì¶”ì²œ ê³„ì‚°
def recommend(user_id, top_n=10):
    similar_users = user_similarity[user_id].argsort()[-11:-1]
    recommendations = []
    for similar_user in similar_users:
        user_movies = user_rating_matrix[similar_user]
        recommendations.extend(user_movies > 0)
    return top_n_movies(recommendations)
```

**ì¥ì **: ê°„ë‹¨í•˜ê³  ì§ê´€ì 
**ë‹¨ì **: í™•ì¥ì„± ë¬¸ì œ (ì‚¬ìš©ì ìˆ˜ ì¦ê°€ ì‹œ)
**ì‚¬ìš©**: ì´ˆê¸° Netflix, IMDb

**2. Item-Based Collaborative Filtering**
```python
# ì˜í™” ê°„ ìœ ì‚¬ë„ ê³„ì‚°
item_similarity = cosine_similarity(user_rating_matrix.T)

def recommend(user_id, movie_id):
    similar_movies = item_similarity[movie_id].argsort()[-10:]
    return similar_movies
```

**ì¥ì **: í™•ì¥ì„± ìš°ìˆ˜
**ë‹¨ì **: ìƒˆ ì•„ì´í…œì— ì•½í•¨ (Cold Start)
**ì‚¬ìš©**: Netflix (BYW - Because You Watched)

**3. Matrix Factorization (SVD)**
```python
from scipy.sparse.linalg import svds

# ì‚¬ìš©ì-ì•„ì´í…œ í–‰ë ¬ ë¶„í•´
U, sigma, Vt = svds(user_rating_matrix, k=50)

# ì ì¬ ìš”ì¸ í™œìš©
predicted_ratings = np.dot(np.dot(U, np.diag(sigma)), Vt)
```

**íŠ¹ì§•**: 
- Netflix Prize ìš°ìŠ¹ ì•Œê³ ë¦¬ì¦˜
- ì ì¬ ìš”ì¸ ë°œê²¬ (ì¥ë¥´, ê°ë… ìŠ¤íƒ€ì¼ ë“±)
- ì •í™•ë„: RMSE 0.8567

**ì‚¬ìš©**: Netflix (2009-2015), Amazon Prime

#### B. Content-Based Filtering (ì½˜í…ì¸  ê¸°ë°˜)

```python
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# ì˜í™” ë©”íƒ€ë°ì´í„°ë¡œ ë²¡í„°í™”
tfidf = TfidfVectorizer()
movie_vectors = tfidf.fit_transform(movie_descriptions)

# ìœ ì‚¬ ì˜í™” ì°¾ê¸°
similarity_matrix = cosine_similarity(movie_vectors)
```

**íŠ¹ì§• ì¶”ì¶œ**:
- ì¥ë¥´ (Genre)
- ê°ë… (Director)
- ë°°ìš° (Cast)
- í‚¤ì›Œë“œ (Keywords)
- ì¤„ê±°ë¦¬ (Plot)

**ì¥ì **: ìƒˆ ì•„ì´í…œì—ë„ ì¶”ì²œ ê°€ëŠ¥
**ë‹¨ì **: ë‹¤ì–‘ì„± ë¶€ì¡±
**ì‚¬ìš©**: IMDb, Letterboxd

#### C. Hybrid Systems (í•˜ì´ë¸Œë¦¬ë“œ)

Netflixì˜ í˜„ì¬ ì‹œìŠ¤í…œ:

```python
# ì—¬ëŸ¬ ëª¨ë¸ ì¡°í•©
final_score = (
    0.3 * collaborative_score +
    0.2 * content_based_score +
    0.3 * deep_learning_score +
    0.1 * popularity_score +
    0.1 * recency_score
)
```

**êµ¬ì„± ìš”ì†Œ**:
1. Collaborative Filtering (30%)
2. Content-Based (20%)
3. Deep Neural Networks (30%)
4. Popularity/Trending (10%)
5. Time Decay (10%)

#### D. Deep Learning ì¶”ì²œ

**1. Neural Collaborative Filtering (NCF)**
```python
import tensorflow as tf

# ì‚¬ìš©ì ì„ë² ë”©
user_embedding = Embedding(num_users, 64)
# ì•„ì´í…œ ì„ë² ë”©
item_embedding = Embedding(num_items, 64)

# MLP ë ˆì´ì–´
mlp = Dense(128, activation='relu')
output = Dense(1, activation='sigmoid')
```

**2. Variational Autoencoders (VAE)**
```python
# Netflixì˜ Mult-VAE
encoder = [Dense(600, activation='tanh'),
           Dense(200, activation='tanh')]
           
latent = Dense(50)  # ì ì¬ ê³µê°„

decoder = [Dense(200, activation='tanh'),
           Dense(600, activation='tanh')]
```

**íŠ¹ì§•**: 
- í¬ì†Œ ë°ì´í„° ì²˜ë¦¬ ìš°ìˆ˜
- ì•”ì‹œì  í”¼ë“œë°±ì— ê°•í•¨
- Netflix ì£¼ë ¥ ëª¨ë¸ (2018-)

**3. Graph Neural Networks (GNN)**

Netflixì˜ SemanticGNN:

```python
# ì§€ì‹ ê·¸ë˜í”„ êµ¬ì„±
# ë…¸ë“œ: ì˜í™”, ë°°ìš°, ê°ë…, ì¥ë¥´
# ì—£ì§€: í˜‘ì—… ì‹ í˜¸, ì˜ë¯¸ì  ê´€ê³„

class SemanticGNN:
    def __init__(self):
        self.node_embeddings = {}
        self.edge_types = ['acted_in', 'directed', 'same_genre']
        
    def aggregate(self, node, neighbors):
        # ê´€ê³„ë³„ ê°€ì¤‘ì¹˜ í•™ìŠµ
        weighted_sum = 0
        for neighbor, edge_type in neighbors:
            weight = self.attention(edge_type)
            weighted_sum += weight * neighbor.embedding
        return weighted_sum
```

**ì¥ì **:
- Cold Start ë¬¸ì œ í•´ê²°
- ì˜ë¯¸ì  ì—°ê²° í™œìš©
- ì„¤ëª… ê°€ëŠ¥í•œ ì¶”ì²œ

**ì‚¬ìš©**: Netflix (2020-), YouTube

---

### 3.3 ì‹¤ì‹œê°„ ì²˜ë¦¬ ê¸°ìˆ 

#### A. ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬

```python
# Apache Kafka + Spark Streaming
from pyspark.streaming.kafka import KafkaUtils

kafkaStream = KafkaUtils.createStream(
    ssc,
    'localhost:2181',
    'user-interactions',
    {'movie-views': 1}
)

# ì‹¤ì‹œê°„ íŠ¹ì§• ì—…ë°ì´íŠ¸
def update_features(rdd):
    for interaction in rdd:
        user_id = interaction['user_id']
        movie_id = interaction['movie_id']
        
        # íŠ¹ì§• ì—…ë°ì´íŠ¸
        update_user_profile(user_id, movie_id)
        update_movie_popularity(movie_id)
        
        # ìºì‹œ ë¬´íš¨í™”
        invalidate_cache(user_id)
```

#### B. Feature Store

```python
# Netflixì˜ Feature Store ì•„í‚¤í…ì²˜
class FeatureStore:
    def __init__(self):
        self.online_store = Redis()   # ì €ì§€ì—° ì½ê¸°
        self.offline_store = S3()     # ë°°ì¹˜ í•™ìŠµ
        
    def get_features(self, entity_id):
        # ì˜¨ë¼ì¸: < 10ms
        return self.online_store.get(entity_id)
    
    def compute_features(self, data):
        # ì˜¤í”„ë¼ì¸: ë°°ì¹˜ ê³„ì‚°
        features = spark.sql("""
            SELECT 
                user_id,
                avg(rating) as avg_rating,
                count(*) as num_reviews,
                variance(rating) as rating_variance
            FROM reviews
            GROUP BY user_id
        """)
        self.offline_store.write(features)
```

---

## 4. í‰ì  ì‹œìŠ¤í…œ ë¹„êµ

### 4.1 ê³„ì‚° ë°©ì‹ ë¹„êµ

| í”Œë«í¼ | ë°©ì‹ | ë²”ìœ„ | íŠ¹ì§• |
|--------|------|------|------|
| **IMDb** | ê°€ì¤‘ í‰ê·  | 0-10 | ëª¨ë“  ì‚¬ìš©ì ì°¸ì—¬, ì¡°ì‘ ë°©ì§€ |
| **Rotten Tomatoes** | ê¸ì • ë¹„ìœ¨ | 0-100% | Fresh/Rotten ì´ë¶„ë²• |
| **Metacritic** | ê°€ì¤‘ í‰ê·  | 0-100 | ë¹„í‰ê°€ í‰íŒ ê¸°ë°˜ ê°€ì¤‘ì¹˜ |
| **Netflix** | ê°œì¸í™” | ì—†ìŒ | ê°œì¸ë³„ ë§ì¶¤ ì¶”ì²œ |

### 4.2 ì‹ ë¢°ë„ ë¶„ì„

**IMDb**
- âœ… ì¥ì : ëŒ€ì¤‘ ì˜ê²¬ ë°˜ì˜
- âŒ ë‹¨ì : íŒ¬ë¤ í­ê²©, ì¡°ì‘ ê°€ëŠ¥ì„±

**Rotten Tomatoes**
- âœ… ì¥ì : ì „ë¬¸ê°€ ê²€ì¦
- âŒ ë‹¨ì : ë‰˜ì•™ìŠ¤ ì†ì‹¤ (3.5ì ë„ Fresh)

**Metacritic**
- âœ… ì¥ì : ê°€ì¥ ì •êµí•œ í‰ê°€
- âŒ ë‹¨ì : ë¶ˆíˆ¬ëª…í•œ ê°€ì¤‘ì¹˜, ì˜í™” ì»¤ë²„ë¦¬ì§€ ë‚®ìŒ

### 4.3 ì‚¬ìš©ì ê´€ì  ì¶”ì²œ

**ì¼ë°˜ ê´€ê°**: IMDb (ëŒ€ì¤‘ ì·¨í–¥)
**ì˜í™” ì• í˜¸ê°€**: Metacritic (ì •êµí•œ í‰ê°€)
**ë¹ ë¥¸ íŒë‹¨**: Rotten Tomatoes (í•œëˆˆì— Fresh/Rotten)
**ê°œì¸í™”**: Netflix (ë§ì¶¤ ì¶”ì²œ)

---

## 5. ì¶”ì²œ ì‹œìŠ¤í…œ ì‹¬í™”

### 5.1 Netflix ì¶”ì²œ ì‹œìŠ¤í…œ ìƒì„¸

#### A. ë‹¤ë‹¨ê³„ íŒŒì´í”„ë¼ì¸

```
1. Candidate Generation (í›„ë³´ ìƒì„±)
   â†“
   - í˜‘ì—… í•„í„°ë§: 10,000ê°œ
   - ì½˜í…ì¸  ê¸°ë°˜: 5,000ê°œ
   - ì¸ê¸°ë„: 1,000ê°œ
   â†“
   ì´ ~16,000ê°œ í›„ë³´

2. Ranking (ìˆœìœ„ ë§¤ê¸°ê¸°)
   â†“
   - PVR (Personalized Video Ranking)
   - ë‹¤ì¤‘ ëª©í‘œ ìµœì í™”
   - ì»¨í…ìŠ¤íŠ¸ ê³ ë ¤ (ì‹œê°„, ê¸°ê¸°)
   â†“
   ìƒìœ„ 500ê°œ ì„ íƒ

3. Page Generation (í˜ì´ì§€ ìƒì„±)
   â†“
   - í–‰ ìƒì„± (Continue Watching, Top Picks)
   - ë‹¤ì–‘ì„± ìµœì í™”
   - ì¤‘ë³µ ì œê±°
   â†“
   ìµœì¢… ì‚¬ìš©ì í˜ì´ì§€
```

#### B. ë‹¤ì¤‘ ëª©í‘œ ìµœì í™”

```python
# Netflixì˜ Multi-Objective Optimization
objectives = {
    'click_probability': 0.3,      # í´ë¦­ í™•ë¥ 
    'watch_time': 0.3,              # ì‹œì²­ ì‹œê°„
    'completion_rate': 0.2,         # ì™„ì£¼ìœ¨
    'diversity': 0.1,               # ë‹¤ì–‘ì„±
    'freshness': 0.1                # ì‹ ì„ ë„
}

total_score = sum(
    weight * objective_score
    for objective, weight in objectives.items()
)
```

#### C. Contextual Bandits (ë¬¸ë§¥ ë°´ë”§)

ì¸ë„¤ì¼ ê°œì¸í™”:

```python
class ContextualBandit:
    def select_thumbnail(self, user_context, movie):
        # ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸
        context = {
            'time_of_day': user_context['time'],
            'device': user_context['device'],
            'recent_genres': user_context['genres']
        }
        
        # ê° ì¸ë„¤ì¼ì˜ ì˜ˆìƒ í´ë¦­ë¥ 
        expected_rewards = []
        for thumbnail in movie.thumbnails:
            reward = self.model.predict(context, thumbnail)
            expected_rewards.append(reward)
        
        # Îµ-greedy: íƒìƒ‰ vs í™œìš©
        if random() < epsilon:
            return random.choice(movie.thumbnails)
        else:
            return max_thumbnail(expected_rewards)
```

#### D. Foundation Model (2024 ìµœì‹ )

Netflixì˜ ì°¨ì„¸ëŒ€ ì¶”ì²œ ëª¨ë¸:

```python
class FoundationRecommender:
    def __init__(self):
        # Transformer ê¸°ë°˜ ì•„í‚¤í…ì²˜
        self.transformer = TransformerModel(
            vocab_size=1000000,  # ì „ì²´ ì½˜í…ì¸ 
            d_model=768,
            num_heads=12,
            num_layers=12
        )
        
    def tokenize_interaction(self, interaction):
        """
        ìƒí˜¸ì‘ìš©ì„ í† í°ìœ¼ë¡œ ë³€í™˜
        - ì˜í™” ID
        - ì‹œì²­ ì‹œê°„
        - ê¸°ê¸° ì •ë³´
        - ì‹œì²­ ì™„ë£Œ ì—¬ë¶€
        """
        token = {
            'movie_id': interaction.movie_id,
            'watch_duration': interaction.duration,
            'device': interaction.device,
            'completed': interaction.completed
        }
        return token
    
    def predict_next(self, user_history):
        """
        ë‹¤ìŒ ì‹œì²­í•  ì½˜í…ì¸  ì˜ˆì¸¡
        """
        tokens = [self.tokenize_interaction(i) 
                  for i in user_history]
        
        # Sliding Window (ê¸´ íˆìŠ¤í† ë¦¬ ì²˜ë¦¬)
        if len(tokens) > max_length:
            tokens = tokens[-max_length:]
        
        # Transformer ì˜ˆì¸¡
        logits = self.transformer(tokens)
        
        # Top-K ìƒ˜í”Œë§
        top_k_movies = torch.topk(logits, k=10)
        return top_k_movies
```

**íŠ¹ì§•**:
- ë‹¨ì¼ ëª¨ë¸ë¡œ ëª¨ë“  use case ì²˜ë¦¬
- ë°˜ì§€ë„ í•™ìŠµ (Semi-Supervised Learning)
- ì¥ê¸° ì‚¬ìš©ì íˆìŠ¤í† ë¦¬ ëª¨ë¸ë§ (ìˆ˜ì²œ ê°œ ìƒí˜¸ì‘ìš©)
- ì‹¤ì‹œê°„ ì ì‘

---

### 5.2 Cold Start ë¬¸ì œ í•´ê²°

#### A. ìƒˆ ì‚¬ìš©ì

**1. ì˜¨ë³´ë”© ì„¤ë¬¸**
```python
# Netflix ê°€ì… ì‹œ
preferences = ask_user([
    "Choose 3 titles you enjoyed",
    "Select favorite genres",
    "Rate these popular movies"
])

# ì´ˆê¸° í”„ë¡œí•„ êµ¬ì„±
initial_profile = ContentBasedRecommender(preferences)
```

**2. ì¸êµ¬í†µê³„ ê¸°ë°˜**
```python
# ìœ ì‚¬í•œ ì‚¬ìš©ì ê·¸ë£¹ ì°¾ê¸°
similar_group = find_demographic_cluster(
    age=user.age,
    location=user.location,
    signup_time=user.signup_time
)

# ê·¸ë£¹ í‰ê·  í™œìš©
recommendations = similar_group.popular_items
```

#### B. ìƒˆ ì˜í™”

**1. ë©”íƒ€ë°ì´í„° í™œìš©**
```python
# ì½˜í…ì¸  ê¸°ë°˜ ì¶”ì²œ
new_movie_features = extract_features(movie)
# â†’ [ì¥ë¥´, ê°ë…, ë°°ìš°, í‚¤ì›Œë“œ, ì¤„ê±°ë¦¬]

similar_movies = find_similar_by_content(new_movie_features)
```

**2. Graph Neural Networks**
```python
# ì˜ë¯¸ì  ì—°ê²° í™œìš©
# "ì‹ ì‘ì´ì§€ë§Œ í¬ë¦¬ìŠ¤í† í¼ ë†€ë€ ê°ë…"
# â†’ ë†€ë€ì˜ ë‹¤ë¥¸ ì˜í™” íŒ¬ì—ê²Œ ì¶”ì²œ
```

---

## 6. í”„ë¡œë•ì…˜ ë ˆë²¨ êµ¬í˜„

### 6.1 í™•ì¥ì„± (Scalability)

#### A. ìˆ˜í‰ í™•ì¥ (Horizontal Scaling)

```python
# Load Balancer
nginx_config = """
upstream api_servers {
    server api1.example.com:8000;
    server api2.example.com:8000;
    server api3.example.com:8000;
}

server {
    location /api/ {
        proxy_pass http://api_servers;
    }
}
"""
```

#### B. ìºì‹± ì „ëµ

**Multi-Layer Caching**

```python
class CacheStrategy:
    def get_recommendations(self, user_id):
        # Layer 1: Browser Cache (1ë¶„)
        if browser_cache.has(user_id):
            return browser_cache.get(user_id)
        
        # Layer 2: CDN Cache (5ë¶„)
        if cdn_cache.has(user_id):
            return cdn_cache.get(user_id)
        
        # Layer 3: Redis (30ë¶„)
        if redis.has(user_id):
            return redis.get(user_id)
        
        # Layer 4: ë°ì´í„°ë² ì´ìŠ¤
        recommendations = db.compute_recommendations(user_id)
        
        # ëª¨ë“  ë ˆì´ì–´ì— ì €ì¥
        redis.set(user_id, recommendations, ttl=1800)
        cdn_cache.set(user_id, recommendations, ttl=300)
        
        return recommendations
```

#### C. ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”©

```python
# User ID ê¸°ë°˜ ìƒ¤ë”©
def get_shard(user_id):
    shard_id = user_id % num_shards
    return database_shards[shard_id]

# ì˜ˆ: 1ì–µ ì‚¬ìš©ìë¥¼ 10ê°œ ìƒ¤ë“œë¡œ ë¶„ì‚°
# Shard 0: user_id % 10 == 0
# Shard 1: user_id % 10 == 1
# ...
```

---

### 6.2 ì‹¤ì‹œê°„ ì²˜ë¦¬

#### A. Lambda Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          BATCH LAYER                      â”‚
â”‚  (HDFS, Spark) - ì •í™•í•œ ì „ì²´ ë¶„ì„         â”‚
â”‚  - ë§¤ì¼ ì‹¤í–‰                               â”‚
â”‚  - ëª¨ë“  íˆìŠ¤í† ë¦¬ ë°ì´í„° ì²˜ë¦¬                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  SERVING LAYER  â”‚
         â”‚   (Cassandra)   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–²
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         SPEED LAYER                       â”‚
â”‚  (Kafka, Flink) - ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸         â”‚
â”‚  - ë°€ë¦¬ì´ˆ ë‹¨ìœ„ ì²˜ë¦¬                        â”‚
â”‚  - ìµœì‹  ì´ë²¤íŠ¸ë§Œ ì²˜ë¦¬                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### B. ì‹¤ì‹œê°„ Feature Engineering

```python
from flink import StreamExecutionEnvironment

env = StreamExecutionEnvironment.get_execution_environment()

# ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
user_stream = env.add_source(KafkaConsumer('user-events'))

def compute_features(user_events):
    """ì‹¤ì‹œê°„ íŠ¹ì§• ê³„ì‚°"""
    return {
        'recent_watches': user_events[-10:],
        'genre_preference': calculate_genre_dist(user_events),
        'watch_time_pattern': time_analysis(user_events),
        'binge_probability': predict_binge(user_events)
    }

features = user_stream.map(compute_features)
features.add_sink(RedisSink())
```

---

### 6.3 A/B í…ŒìŠ¤íŒ…

#### Netflixì˜ ì‹¤í—˜ í”Œë«í¼

```python
class ABTestFramework:
    def __init__(self):
        self.experiments = {}
        
    def create_experiment(self, name, variants):
        """
        ì‹¤í—˜ ìƒì„±
        
        ì˜ˆ: ì¸ë„¤ì¼ A vs B í…ŒìŠ¤íŠ¸
        """
        self.experiments[name] = {
            'control': variants['control'],
            'treatment': variants['treatment'],
            'metrics': ['ctr', 'watch_time', 'completion']
        }
    
    def assign_variant(self, user_id, experiment):
        """ì‚¬ìš©ìë¥¼ ì‹¤í—˜ ê·¸ë£¹ì— í• ë‹¹"""
        hash_value = hash(f"{user_id}_{experiment}")
        if hash_value % 2 == 0:
            return 'control'
        else:
            return 'treatment'
    
    def track_metric(self, user_id, experiment, metric, value):
        """ë©”íŠ¸ë¦­ ì¶”ì """
        variant = self.assign_variant(user_id, experiment)
        self.metrics_db.record({
            'experiment': experiment,
            'variant': variant,
            'metric': metric,
            'value': value,
            'timestamp': now()
        })
    
    def analyze_results(self, experiment):
        """í†µê³„ì  ìœ ì˜ì„± ê²€ì •"""
        control_data = self.get_data(experiment, 'control')
        treatment_data = self.get_data(experiment, 'treatment')
        
        # T-test
        t_stat, p_value = ttest_ind(control_data, treatment_data)
        
        if p_value < 0.05:
            return "Statistically significant"
        else:
            return "No significant difference"
```

---

### 6.4 ëª¨ë‹ˆí„°ë§ & ì•Œë¦¼

```python
# Prometheus + Grafana
from prometheus_client import Counter, Histogram

# ë©”íŠ¸ë¦­ ì •ì˜
request_count = Counter(
    'api_requests_total',
    'Total API requests'
)

response_time = Histogram(
    'api_response_time_seconds',
    'API response time'
)

# ëª¨ë‹ˆí„°ë§
@app.route('/recommendations')
def get_recommendations():
    request_count.inc()
    
    with response_time.time():
        recommendations = recommendation_engine.get()
    
    return recommendations

# ì•Œë¦¼ ê·œì¹™
alerts = """
- alert: HighErrorRate
  expr: rate(api_errors_total[5m]) > 0.05
  for: 5m
  annotations:
    summary: Error rate > 5%
    
- alert: SlowResponse
  expr: api_response_time_seconds > 1.0
  for: 10m
  annotations:
    summary: API response time > 1s
"""
```

---

## 7. ìš°ë¦¬ í”„ë¡œì íŠ¸ì™€ì˜ ë¹„êµ

### 7.1 í˜„ì¬ êµ¬í˜„ vs ìƒì—…ì  ì‹œìŠ¤í…œ

| í•­ëª© | ìš°ë¦¬ í”„ë¡œì íŠ¸ | ìƒì—…ì  ì‹œìŠ¤í…œ |
|------|-------------|-------------|
| **ì•„í‚¤í…ì²˜** | ëª¨ë†€ë¦¬ì‹ (FastAPI) | ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ |
| **ë°ì´í„°ë² ì´ìŠ¤** | SQLite | Cassandra, PostgreSQL |
| **ìºì‹±** | ì—†ìŒ | Redis, Memcached (ë‹¤ì¸µ) |
| **ê°ì„± ë¶„ì„** | í‚¤ì›Œë“œ ê¸°ë°˜ | BERT, Transformer |
| **ì¶”ì²œ ì‹œìŠ¤í…œ** | ì—†ìŒ | í˜‘ì—… í•„í„°ë§ + ë”¥ëŸ¬ë‹ |
| **í™•ì¥ì„±** | ë‹¨ì¼ ì„œë²„ | ë¶„ì‚° í´ëŸ¬ìŠ¤í„° |
| **ì‹¤ì‹œê°„ ì²˜ë¦¬** | ì—†ìŒ | Kafka, Flink |
| **A/B í…ŒìŠ¤íŒ…** | ì—†ìŒ | ìë™í™”ëœ í”Œë«í¼ |

### 7.2 ë‹¨ê³„ë³„ ê°œì„  ë¡œë“œë§µ

#### Phase 1: ê¸°ë³¸ ê°œì„  (1-2ì£¼)

```python
# 1. Redis ìºì‹± ì¶”ê°€
@app.get("/movies")
def get_movies(cache: Redis = Depends(get_redis)):
    cached = cache.get("movies_list")
    if cached:
        return json.loads(cached)
    
    movies = db.query(Movie).all()
    cache.set("movies_list", json.dumps(movies), ex=300)
    return movies

# 2. PostgreSQL ì „í™˜
DATABASE_URL = "postgresql://user:pass@localhost/moviedb"

# 3. ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ì‹±
class Movie(Base):
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)  # â† ì¸ë±ìŠ¤ ì¶”ê°€
    genre = Column(String, index=True)   # â† ì¸ë±ìŠ¤ ì¶”ê°€
```

#### Phase 2: AI ëª¨ë¸ í†µí•© (2-4ì£¼)

```python
# KoBERT ê°ì„± ë¶„ì„
from transformers import AutoModelForSequenceClassification

class SentimentAnalyzer:
    def __init__(self):
        self.model = AutoModelForSequenceClassification.from_pretrained(
            "monologg/kobert",
            num_labels=3
        )
        self.tokenizer = AutoTokenizer.from_pretrained("monologg/kobert")
    
    def analyze(self, text):
        inputs = self.tokenizer(text, return_tensors="pt")
        outputs = self.model(**inputs)
        probs = torch.softmax(outputs.logits, dim=1)
        
        sentiment_map = {0: 'negative', 1: 'neutral', 2: 'positive'}
        sentiment_idx = torch.argmax(probs).item()
        
        return {
            'sentiment': sentiment_map[sentiment_idx],
            'score': probs[0][sentiment_idx].item(),
            'probabilities': probs[0].tolist()
        }
```

#### Phase 3: ì¶”ì²œ ì‹œìŠ¤í…œ (4-6ì£¼)

```python
# í˜‘ì—… í•„í„°ë§ ì¶”ê°€
from surprise import SVD, Dataset, Reader

class RecommendationEngine:
    def __init__(self):
        self.model = SVD()
        
    def train(self, ratings_df):
        reader = Reader(rating_scale=(1, 5))
        data = Dataset.load_from_df(
            ratings_df[['user_id', 'movie_id', 'rating']], 
            reader
        )
        trainset = data.build_full_trainset()
        self.model.fit(trainset)
    
    def recommend(self, user_id, n=10):
        # ëª¨ë“  ì˜í™”ì— ëŒ€í•œ ì˜ˆìƒ í‰ì  ê³„ì‚°
        predictions = []
        for movie_id in all_movie_ids:
            pred = self.model.predict(user_id, movie_id)
            predictions.append((movie_id, pred.est))
        
        # ìƒìœ„ Nê°œ ë°˜í™˜
        predictions.sort(key=lambda x: x[1], reverse=True)
        return predictions[:n]
```

#### Phase 4: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì „í™˜ (6-12ì£¼)

```
í˜„ì¬ êµ¬ì¡°:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FastAPI App    â”‚
â”‚  (Monolithic)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ëª©í‘œ êµ¬ì¡°:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Movie   â”‚  â”‚  Review  â”‚  â”‚  Rating  â”‚  â”‚   AI     â”‚
â”‚  Service â”‚  â”‚  Service â”‚  â”‚  Service â”‚  â”‚  Service â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚             â”‚              â”‚              â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚ API Gateway â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Phase 5: í”„ë¡œë•ì…˜ ì¤€ë¹„ (12-16ì£¼)

```python
# 1. Docker ì»¨í…Œì´ë„ˆí™”
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
CMD ["uvicorn", "main:app", "--host", "0.0.0.0"]

# 2. Kubernetes ë°°í¬
apiVersion: apps/v1
kind: Deployment
metadata:
  name: movie-api
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: api
        image: movie-api:latest
        resources:
          limits:
            memory: "512Mi"
            cpu: "500m"

# 3. ëª¨ë‹ˆí„°ë§
from prometheus_fastapi_instrumentator import Instrumentator

Instrumentator().instrument(app).expose(app)

# 4. ë¡œê¹…
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.middleware("http")
async def log_requests(request, call_next):
    logger.info(f"{request.method} {request.url}")
    response = await call_next(request)
    logger.info(f"Status: {response.status_code}")
    return response
```

---

## 8. í•µì‹¬ ì¸ì‚¬ì´íŠ¸ & ê²°ë¡ 

### 8.1 ìƒì—…ì  ì‹œìŠ¤í…œì˜ ê³µí†µì 

1. **ë°ì´í„° ì¤‘ì‹¬**: ëª¨ë“  ê²°ì •ì´ ë°ì´í„° ê¸°ë°˜
2. **ì‚¬ìš©ì ê²½í—˜ ìµœìš°ì„ **: ì •í™•ë„ë³´ë‹¤ ë§Œì¡±ë„
3. **ì§€ì†ì  ê°œì„ **: A/B í…ŒìŠ¤íŠ¸ë¡œ ëŠì„ì—†ì´ ìµœì í™”
4. **í™•ì¥ì„±**: ì²˜ìŒë¶€í„° ëŒ€ê·œëª¨ë¥¼ ê³ ë ¤í•œ ì„¤ê³„
5. **ë‹¤ì–‘ì„±**: ì •í™•ë„ì™€ ë‹¤ì–‘ì„±ì˜ ê· í˜•

### 8.2 ì„±ê³µ ìš”ì¸

**Netflix**:
- ì´ˆê¸° íˆ¬ì (Netflix Prize $1M)
- ë°ì´í„° ê³¼í•™ íŒ€ ê·œëª¨ (ìˆ˜ë°± ëª…)
- ì‹¤í—˜ ë¬¸í™” (ì—°ê°„ ìˆ˜ì²œ ê°œ A/B í…ŒìŠ¤íŠ¸)

**IMDb**:
- ë°©ëŒ€í•œ ë°ì´í„°ë² ì´ìŠ¤ (30ë…„ ì´ìƒ)
- ì»¤ë®¤ë‹ˆí‹° ì°¸ì—¬
- Amazonê³¼ì˜ ì‹œë„ˆì§€

**Rotten Tomatoes**:
- ë¸Œëœë“œ ì¸ì§€ë„ (Fresh/Rotten)
- ì „ë¬¸ ë¹„í‰ê°€ ë„¤íŠ¸ì›Œí¬
- ëª…í™•í•œ í‰ê°€ ê¸°ì¤€

### 8.3 ìš°ë¦¬ê°€ ë°°ìš¸ ì 

1. **ë‹¨ìˆœí•¨ì—ì„œ ì‹œì‘**: Netflixë„ ì´ˆê¸°ì—ëŠ” ë‹¨ìˆœí•œ í˜‘ì—… í•„í„°ë§
2. **ì ì§„ì  ê°œì„ **: í•œ ë²ˆì— ì™„ë²½í•˜ì§€ ì•Šì•„ë„ ë¨
3. **ì‚¬ìš©ì í”¼ë“œë°±**: ì¡°ê¸°ë¶€í„° ì‹¤ì œ ì‚¬ìš©ì ë°ì´í„° ìˆ˜ì§‘
4. **í™•ì¥ ê°€ëŠ¥í•œ ì„¤ê³„**: ë‚˜ì¤‘ì— ë°”ê¾¸ê¸° ì–´ë ¤ìš´ ë¶€ë¶„ ë¨¼ì € ê³ ë ¤
5. **ì‹¤í—˜ ë¬¸í™”**: ê°€ì„¤ì„ ì„¸ìš°ê³  ê²€ì¦í•˜ëŠ” ìŠµê´€

### 8.4 ì‹¤ë¬´ ì ìš© ì œì•ˆ

**ì¦‰ì‹œ ì ìš© ê°€ëŠ¥**:
- Redis ìºì‹±
- PostgreSQL ì „í™˜
- ê¸°ë³¸ ì¸ë±ì‹±
- ë¡œê¹… ì‹œìŠ¤í…œ

**ì¤‘ê¸° ëª©í‘œ (3-6ê°œì›”)**:
- KoBERT ê°ì„± ë¶„ì„
- í˜‘ì—… í•„í„°ë§ ì¶”ì²œ
- Docker ì»¨í…Œì´ë„ˆí™”
- ê¸°ë³¸ ëª¨ë‹ˆí„°ë§

**ì¥ê¸° ëª©í‘œ (6-12ê°œì›”)**:
- ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì „í™˜
- ë”¥ëŸ¬ë‹ ì¶”ì²œ ì‹œìŠ¤í…œ
- ì‹¤ì‹œê°„ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
- ìë™í™”ëœ A/B í…ŒìŠ¤íŒ…

---

## ì°¸ê³  ë¬¸í—Œ

1. Netflix Tech Blog: https://netflixtechblog.com/
2. IMDb Datasets: https://www.imdb.com/interfaces/
3. Rotten Tomatoes Methodology: https://www.rottentomatoes.com/about
4. "The Netflix Recommender System: Algorithms, Business Value, and Innovation" (ACM TMIS, 2015)
5. "Deep Learning for Recommender Systems" (RecSys, 2017-2024)
6. "Matrix Factorization Techniques for Recommender Systems" (IEEE Computer, 2009)

---

**ì‘ì„±:** ì¬ì˜ (Inha University Hospital Medical Research Institute)
**ë‚ ì§œ:** 2024-12-17
**ë²„ì „:** 1.0.0
